package leetcode;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

public class MapSetProblems {
    /**
     * Given an unsorted array nums, return the length of the longest consecutive elements sequence
     * @param nums unsorted integer array
     * @return length of the longest consecutive sequence that can be formed
     */
    public static int longestConsecutiveSequence(int[] nums) {
        if (nums == null || nums.length < 1) {
            return 0;
        }
        //add all values to a set for O(1) look-up
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }
        int longestSequence = 1;
        //go through the set and form sequences
        for (int val : numSet) {
            //first check if the prev consecutive element is not in the set, otherwise it would be covered already
            if (!numSet.contains(val - 1)) {
                int currentStreak = 1;
                //form the sequence by checking if the set contains each consecutive element
                while (numSet.contains(val + 1)) {
                    currentStreak++;
                    longestSequence = Math.max(longestSequence, currentStreak);
                    val++;
                }
            }
        }
        return longestSequence;
    }

    /**
     * Generates a list of numbers by comparing 2 adjacent digits in the input and replaces the 2 with the larger of the 2 compared digits
     * then finds the smallest number in that list of numbers
     * @param n input
     * @return smallest number generated by replacing 2 adjacent digits with the larger of the 2 digits
     */
    public static int compareAdjacents(int n) {
        if (n < 10) {
            return n;
        }
        TreeSet<Integer> numbers = new TreeSet<>();
        //convert n to string form
        String stringForm = Integer.toString(n);
        //compare each set of 2 adjacent numbers, pick larger one and form new string, then add to set
        for (int i = 0; i < stringForm.length() - 1; i++) {
            int first = Integer.parseInt(stringForm.charAt(i) + "");
            int second = Integer.parseInt(stringForm.charAt(i + 1) + "");
            int larger = Math.max(first, second);
            StringBuilder sub = new StringBuilder(stringForm);
            if (larger == first) {
                sub.deleteCharAt(i + 1);
            }
            else {
                sub.deleteCharAt(i);
            }
            numbers.add(Integer.parseInt(sub.toString()));
        }
        return numbers.first();
    }

    /**
     * Given an array of integers, find the length of the longest strictly increasing subsequence
     * Subsequence is any sub-set of the array that maintains original order
     * @param nums array of integers
     * @return length of the longest increasing subsequence
     */
    public static int longestIncreasingSubsequence(int[] nums) {
        //base case
        if (nums == null || nums.length == 0) {
            return 0;
        }
        //build the sequence with a tree set
        TreeSet<Integer> subSet = new TreeSet<>();
        //by default, add the 1st element
        subSet.add(nums[0]);
        //iterate through nums from the 2nd element
        for (int i = 1; i < nums.length; i++) {
            //if nums[i] is greater than anything in the set, add it to the set
            if (nums[i] > subSet.last()) {
                subSet.add(nums[i]);
            }
            //otherwise replace the smallest element >= nums[i] with nums[i]
            else {
                subSet.remove(subSet.ceiling(nums[i]));
                subSet.add(nums[i]);
            }
        }
        //answer is the size of subSet
        return subSet.size();
    }

    /**
     * Given an array of 1's and 0's, find the length of the longest contiguous sub-array such that there are equal 1's and 0's
     * @param binaryArr integer array of only 1's and 0's
     * @return length of the longest contiguous sub-array such that there are equal 1's and 0's
     */
    public static int findMaxLengthEqualOnesZeroes(int[] binaryArr) {
        //use a counter that goes up with 1 and goes down with 0
        //a sub-array with equal 1's and 0's is found when the counter hits a value that is seen before
        //use a map to store the count at each step and its indices
        Map<Integer, Integer> countIndexMap = new HashMap<>();
        int count = 0;
        int maxLen = 0;
        //put (0, -1) in the map to represent the starting point
        countIndexMap.put(0, -1);
        for (int i = 0; i < binaryArr.length; i++) {
            if (binaryArr[i] == 1) {
                count++;
            }
            else {
                count--;
            }
            //check if the current count exists in the map, and update the max length if it does
            if (countIndexMap.containsKey(count)) {
                maxLen = Math.max(maxLen, i - countIndexMap.get(count));
            }
            else {
                //only want the first occurrence of each count for calculations
                countIndexMap.put(count, i);
            }
        }
        return maxLen;
    }
}
