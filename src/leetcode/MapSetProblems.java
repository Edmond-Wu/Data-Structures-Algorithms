package leetcode;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.TreeSet;

public class MapSetProblems {
    /**
     * Given an unsorted array nums, return the length of the longest consecutive elements sequence
     * @param nums unsorted integer array
     * @return length of the longest consecutive sequence that can be formed
     */
    public static int longestConsecutiveSequence(int[] nums) {
        if (nums == null || nums.length < 1) {
            return 0;
        }
        //add all values to a set for O(1) look-up
        Set<Integer> numSet = new HashSet<>();
        for (int num : nums) {
            numSet.add(num);
        }
        int longestSequence = 1;
        //go through the set and form sequences
        for (int val : numSet) {
            //first check if the prev consecutive element is not in the set, otherwise it would be covered already
            if (!numSet.contains(val - 1)) {
                int currentStreak = 1;
                //form the sequence by checking if the set contains each consecutive element
                while (numSet.contains(val + 1)) {
                    currentStreak++;
                    longestSequence = Math.max(longestSequence, currentStreak);
                    val++;
                }
            }
        }
        return longestSequence;
    }

    /**
     * Generates a list of numbers by comparing 2 adjacent digits in the input and replaces the 2 with the larger of the 2 compared digits
     * then finds the smallest number in that list of numbers
     * @param n input
     * @return smallest number generated by replacing 2 adjacent digits with the larger of the 2 digits
     */
    public static int compareAdjacents(int n) {
        if (n < 10) {
            return n;
        }
        TreeSet<Integer> numbers = new TreeSet<>();
        //convert n to string form
        String stringForm = Integer.toString(n);
        //compare each set of 2 adjacent numbers, pick larger one and form new string, then add to set
        for (int i = 0; i < stringForm.length() - 1; i++) {
            int first = Integer.parseInt(stringForm.charAt(i) + "");
            int second = Integer.parseInt(stringForm.charAt(i + 1) + "");
            int larger = Math.max(first, second);
            StringBuilder sub = new StringBuilder(stringForm);
            if (larger == first) {
                sub.deleteCharAt(i + 1);
            }
            else {
                sub.deleteCharAt(i);
            }
            numbers.add(Integer.parseInt(sub.toString()));
        }
        return numbers.first();
    }

    /**
     * Given an array of integers, find the length of the longest strictly increasing subsequence
     * Subsequence is any sub-set of the array that maintains original order
     * @param nums array of integers
     * @return length of the longest increasing subsequence
     */
    public static int longestIncreasingSubsequence(int[] nums) {
        //base case
        if (nums == null || nums.length == 0) {
            return 0;
        }
        //build the sequence with a tree set
        TreeSet<Integer> subSet = new TreeSet<>();
        //by default, add the 1st element
        subSet.add(nums[0]);
        //iterate through nums from the 2nd element
        for (int i = 1; i < nums.length; i++) {
            //if nums[i] is greater than anything in the set, add it to the set
            if (nums[i] > subSet.last()) {
                subSet.add(nums[i]);
            }
            //otherwise replace the smallest element >= nums[i] with nums[i]
            else {
                subSet.remove(subSet.ceiling(nums[i]));
                subSet.add(nums[i]);
            }
        }
        //answer is the size of subSet
        return subSet.size();
    }

    /**
     * Given an array of 1's and 0's, find the length of the longest contiguous sub-array such that there are equal 1's and 0's
     * @param binaryArr integer array of only 1's and 0's
     * @return length of the longest contiguous sub-array such that there are equal 1's and 0's
     */
    public static int findMaxLengthEqualOnesZeroes(int[] binaryArr) {
        //use a counter that goes up with 1 and goes down with 0
        //a sub-array with equal 1's and 0's is found when the counter hits a value that is seen before
        //use a map to store the count at each step and its indices
        Map<Integer, Integer> countIndexMap = new HashMap<>();
        int count = 0;
        int maxLen = 0;
        //put (0, -1) in the map to represent the starting point
        countIndexMap.put(0, -1);
        for (int i = 0; i < binaryArr.length; i++) {
            if (binaryArr[i] == 1) {
                count++;
            }
            else {
                count--;
            }
            //check if the current count exists in the map, and update the max length if it does
            if (countIndexMap.containsKey(count)) {
                maxLen = Math.max(maxLen, i - countIndexMap.get(count));
            }
            else {
                //only want the first occurrence of each count for calculations
                countIndexMap.put(count, i);
            }
        }
        return maxLen;
    }

    /**
     * Given an array nums and an integer target k, find the # of subarrays that sum up to k
     * @param nums array of integers
     * @param k target to sum up to
     * @return # of subarrays that add up to k
     */
    public static int subArraySumEqualsK(int[] nums, int k) {
        //store cumulative/prefix sum occurrences in the map
        Map<Integer, Integer> sumCountMap = new HashMap<>();
        int count = 0;
        int sum = 0;
        sumCountMap.put(0, 1);
        for (int num : nums) {
            sum += num;
            //increment count if sum - k is in the map
            //determine the number of times a subarray with sum k has occurred up to the current index
            count += sumCountMap.getOrDefault(sum - k, 0);
            //update map
            sumCountMap.put(sum, sumCountMap.getOrDefault(sum, 0) + 1);
        }
        return count;
    }

    /**
     * Same problem as the previous method, but with a 2D matrix instead of a 1D array
     * @param matrix 2D integer matrix
     * @param k target to sum to
     * @return # of submatrices that add to k
     */
    public static int subMatrixSumEqualsK(int[][] matrix, int k) {
        int count = 0;
        int numRows = matrix.length;
        int numCols = matrix[0].length;
        //go through each sub-matrix by using 2 row iterators
        for (int row1 = 0; row1 < numRows; row1++) {
            int[] prefixSums = new int[numCols];
            for (int row2 = row1; row2 < numRows; row2++) {
                Map<Integer, Integer> pSumsCountMap = new HashMap<>();
                int pSum = 0;
                //empty matrix is 0
                pSumsCountMap.put(0, 1);
                for (int col = 0; col < numCols; col++) {
                    //update the prefix sums
                    prefixSums[col] += matrix[row2][col];
                    pSum += prefixSums[col];
                    //increment count by the map count of pSum - k
                    count += pSumsCountMap.getOrDefault(pSum - k, 0);
                    //update the map
                    pSumsCountMap.put(pSum, pSumsCountMap.getOrDefault(pSum, 0) + 1);
                }
            }
        }
        return count;
    }
}
